#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, dgtl1,  EncoderDriveLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderDriveRight, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  Launcher,       sensorQuadEncoder)
#pragma config(Motor,  port1,           Elevator,      tmotorVex393, openLoop)
#pragma config(Motor,  port2,           DriveLeftOne,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           DriveLeftTwo,  tmotorVex393, openLoop)
#pragma config(Motor,  port4,           LauncherOne,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           LauncherTwo,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           DriveRightOne, tmotorVex393, openLoop)
#pragma config(Motor,  port7,           DriveRightTwo, tmotorVex393, openLoop)
#pragma config(Motor,  port8,           LauncherThree, tmotorVex393, openLoop)
#pragma config(Motor,  port9,           LauncherFour,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          Hopper,        tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//////////////////////////////////Start Drive True Speed/////////////////////////////////
const int joy_threshold = 10; // maximum error +/- of joysticks when released

// compensates for non-linearity of control value vs speed curve
const unsigned int TrueSpeed[128] =
{
  0,  9,  9,  9, 10, 10, 10, 10, 11, 11,
 11, 11, 12, 12, 12, 12, 12, 13, 13, 13,
 13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
 16, 16, 17, 17, 17, 18, 18, 18, 18, 19,
 19, 19, 20, 20, 20, 21, 21, 21, 22, 22,
 22, 23, 23, 23, 24, 24, 24, 25, 25, 26,
 26, 27, 27, 27, 28, 28, 28, 29, 29, 30,
 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,
 36, 36, 37, 37, 38, 38, 39, 40, 40, 41,
 42, 43, 44, 45, 45, 46, 47, 48, 49, 50,
 51, 52, 54, 55, 55, 57, 59, 61, 63, 65,
 67, 70, 72, 74, 76, 80, 84, 88, 93, 97,
101,106,108,111,114,119,124,127
};

task UserDrive()
{
	float left_drive_pwr;
  float right_drive_pwr;

	while (1)
	{
		left_drive_pwr = vexRT[Ch3];
    right_drive_pwr = vexRT[Ch2];

    /////////////////////////////////////////
    // linear speed control with threshold //
    /////////////////////////////////////////

    // left
    if(left_drive_pwr > joy_threshold)
      left_drive_pwr = TrueSpeed[left_drive_pwr];
    else if(left_drive_pwr < -joy_threshold)
      left_drive_pwr = -TrueSpeed[-left_drive_pwr];
    else
      left_drive_pwr = 0;

    // right
    if(right_drive_pwr > joy_threshold)
      right_drive_pwr = TrueSpeed[right_drive_pwr];
    else if(right_drive_pwr < -joy_threshold)
      right_drive_pwr = -TrueSpeed[-right_drive_pwr];
    else
      right_drive_pwr = 0;

    // "precise control" buttons
    if(vexRT[Btn5D] + vexRT[Btn5U] + vexRT[Btn6D] + vexRT[Btn6U] > 0)
    {
      left_drive_pwr *= 0.7;
      right_drive_pwr *= 0.7;
    }

    /////////////////////////////////
    // "anti-jerk" gradual control //
    /////////////////////////////////

    // left
    if(left_drive_pwr > motor[DriveLeftOne])
      motor[DriveLeftOne] += 1;
    else if(left_drive_pwr < motor[DriveLeftOne])
      motor[DriveLeftOne] -= 1;
    motor[DriveLeftTwo] = motor[DriveLeftOne];

    // right
    if(right_drive_pwr > motor[DriveRightOne])
      motor[DriveRightOne] += 1;
    else if(right_drive_pwr < motor[DriveRightOne])
      motor[DriveRightOne] -= 1;
    motor[DriveRightTwo] = motor[DriveRightOne];

    wait1Msec(1);
	}
}
//////////////////////////////////End Drive True Speed///////////////////////////////////

/////////////////////////////////Start FlyWheel Control//////////////////////////////////
task FlyWheelSafe()
{
	motor[LauncherOne] = 25;
	motor[LauncherTwo] = 25;
	motor[LauncherThree] = 25;
	motor[LauncherFour] = 25;
	wait1Msec(500);
	motor[LauncherOne] = 50;
	motor[LauncherTwo] = 50;
	motor[LauncherThree] = 50;
	motor[LauncherFour] = 50;
	wait1Msec(500);
	motor[LauncherOne] = 75;
	motor[LauncherTwo] = 75;
	motor[LauncherThree] = 75;
	motor[LauncherFour] = 75;
	wait1Msec(500);
	motor[LauncherOne] = 90;
	motor[LauncherTwo] = 90;
	motor[LauncherThree] = 90;
	motor[LauncherFour] = 90;
	wait1Msec(500);
	motor[LauncherOne] = 127;
	motor[LauncherTwo] = 127;
	motor[LauncherThree] = 127;
	motor[LauncherFour] = 127;
	wait1Msec(1);
}


	/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*                        Copyright (c) James Pearman                          */
/*                                   2015                                      */
/*                            All Rights Reserved                              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Module:     flywheel.c                                                   */
/*    Author:     James Pearman                                                */
/*    Created:    28 June 2015                                                 */
/*                                                                             */
/*    Revisions:                                                               */
/*                V1.00  28 June 2015 - Initial release                        */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    An example of flywheel/shooter velocity control using the TBH algorithm  */
/*    Test system uses three motors with 25:2 gearing to the flywheel.         */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              25

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393T          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393R          627.2
#define MOTOR_TPR_QUAD          360.0

// Structure to gather all the flywheel ralated data
typedef struct _fw_controller {
    long            counter;                ///< loop counter used for debug

    // encoder tick per revolution
    float           ticks_per_rev;          ///< encoder ticks per revolution

    // Encoder
    long            e_current;              ///< current encoder count
    long            e_last;                 ///< current encoder count

    // velocity measurement
    float           v_current;              ///< current velocity in rpm
    long            v_time;                 ///< Time of last velocity calculation

    // TBH control algorithm variables
    long            target;                 ///< target velocity
    long            current;                ///< current velocity
    long            last;                   ///< last velocity
    float           error;                  ///< error between actual and target velocities
    float           last_error;             ///< error last time update called
    float           gain;                   ///< gain
    float           drive;                  ///< final drive out of TBH (0.0 to 1.0)
    float           drive_at_zero;          ///< drive at last zero crossing
    long            first_cross;            ///< flag indicating first zero crossing
    float           drive_approx;           ///< estimated open loop drive

    // final motor drive
    long            motor_drive;            ///< final motor control value
    } fw_controller;

// Make the controller global for easy debugging
static  fw_controller   flywheel;

/*-----------------------------------------------------------------------------*/
/** @brief      Set the flywheen motors                                        */
/** @param[in]  value motor control value                                      */
/*-----------------------------------------------------------------------------*/
void
FwMotorSet( int value )
{
    motor[ LauncherOne ] = value;
    motor[ LauncherTwo ] = value;
    motor[ LauncherThree ] = value;
		motor[ LauncherFour ] = value;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Get the flywheen motor encoder count                           */
/*-----------------------------------------------------------------------------*/
long
FwMotorEncoderGet()
{
    return( SensorValue[Launcher] );
}

/*-----------------------------------------------------------------------------*/
/** @brief      Set the controller position                                    */
/** @param[in]  fw pointer to flywheel controller structure                    */
/** @param[in]  desired velocity                                               */
/** @param[in]  predicted_drive estimated open loop motor drive                */
/*-----------------------------------------------------------------------------*/
void
FwVelocitySet( fw_controller *fw, int velocity, float predicted_drive )
{
    // set target velocity (motor rpm)
    fw->target        = velocity;

    // Set error so zero crossing is correctly detected
    fw->error         = fw->target - fw->current;
    fw->last_error    = fw->error;

    // Set predicted open loop drive value
    fw->drive_approx  = predicted_drive;
    // Set flag to detect first zero crossing
    fw->first_cross   = 1;
    // clear tbh variable
    fw->drive_at_zero = 0;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Calculate the current flywheel motor velocity                  */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwCalculateSpeed( fw_controller *fw )
{
    int     delta_ms;
    int     delta_enc;

    // Get current encoder value
    fw->e_current = FwMotorEncoderGet();

    // This is just used so we don't need to know how often we are called
    // how many mS since we were last here
    delta_ms   = nSysTime - fw->v_time;
    fw->v_time = nSysTime;

    // Change in encoder count
    delta_enc = (fw->e_current - fw->e_last);

    // save last position
    fw->e_last = fw->e_current;

    // Calculate velocity in rpm
    fw->v_current = (1000.0 / delta_ms) * delta_enc * 60.0 / fw->ticks_per_rev;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Update the velocity tbh controller variables                   */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwControlUpdateVelocityTbh( fw_controller *fw )
{
    // calculate error in velocity
    // target is desired velocity
    // current is measured velocity
    fw->error = fw->target - fw->current;

    // Use Kp as gain
    fw->drive =  fw->drive + (fw->error * fw->gain);

    // Clip - we are only going forwards
    if( fw->drive > 1 )
          fw->drive = 1;
    if( fw->drive < 0 )
          fw->drive = 0;

    // Check for zero crossing
    if( sgn(fw->error) != sgn(fw->last_error) ) {
        // First zero crossing after a new set velocity command
        if( fw->first_cross ) {
            // Set drive to the open loop approximation
            fw->drive = fw->drive_approx;
            fw->first_cross = 0;
        }
        else
            fw->drive = 0.5 * ( fw->drive + fw->drive_at_zero );

        // Save this drive value in the "tbh" variable
        fw->drive_at_zero = fw->drive;
    }

    // Save last error
    fw->last_error = fw->error;
}

/*-----------------------------------------------------------------------------*/
/** @brief     Task to control the velocity of the flywheel                    */
/*-----------------------------------------------------------------------------*/
task
FwControlTask()
{
    fw_controller *fw = &flywheel;

    // Set the gain
    fw->gain = 0.00025;

    // We are using encoder
    // Set the encoder ticks per revolution
    fw->ticks_per_rev = MOTOR_TPR_QUAD;

    while(1)
        {
        // debug counter
        fw->counter++;

        // Calculate velocity
        FwCalculateSpeed( fw );

        // Set current speed for the tbh calculation code
        fw->current = fw->v_current;

        // Do the velocity TBH calculations
        FwControlUpdateVelocityTbh( fw ) ;

        // Scale drive into the range the motors need
        fw->motor_drive  = (fw->drive * FW_MAX_POWER) + 0.5;

        // Final Limit of motor values - don't really need this
        if( fw->motor_drive >  127 ) fw->motor_drive =  127;
        if( fw->motor_drive < -127 ) fw->motor_drive = -127;

        // and finally set the motor control value
        FwMotorSet( fw->motor_drive );

        // Run at somewhere between 20 and 50mS
        wait1Msec( FW_LOOP_SPEED );
        }
}

//////////////////////////////////End FlyWheel Control///////////////////////////////////

//////////////////////////////////Start Intake Control///////////////////////////////////
task Intake()
{

}
///////////////////////////////////End Intake Control////////////////////////////////////

///////////////////////////////////Start PID Control/////////////////////////////////////

// PID using optical shaft encoder
//
// Shaft encoder has 360 pulses per revolution
//

#define PID_SENSOR_INDEXL    EncoderDriveLeft
#define PID_SENSOR_SCALEL    1

#define PID_MOTOR_INDEXL     DriveLeftOne
#define PID_MOTOR_SCALEL     -1

#define PID_DRIVE_MAXL       127
#define PID_DRIVE_MINL     (-127)

#define PID_INTEGRAL_LIMITL  50

// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
float  pidL_Kp = 2.0;
float  pidL_Ki = 0.04;
float  pidL_Kd = 0.0;

static int   pidRunningL = 1;
static float pidRequestedValueL;

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task PIDLeftControl()
{
		motor[DriveLeftTwo] = motor[DriveLeftOne];    //Keep Left Drive Motor Power The Same

    float  pidSensorCurrentValueL;

    float  pidErrorL;
    float  pidLastErrorL;
    float  pidIntegralL;
    float  pidDerivativeL;
    float  pidDriveL;

    // If we are using an encoder then clear it
    if( SensorType[ PID_SENSOR_INDEXL ] == sensorQuadEncoder )
        SensorValue[ PID_SENSOR_INDEXL ] = 0;

    // Init the variables - thanks Glenn :)
    pidLastErrorL  = 0;
    pidIntegralL   = 0;

    while( true )
        {
        // Is PID control active ?
        if( pidRunningL )
            {
            // Read the sensor value and scale
            pidSensorCurrentValueL = SensorValue[ PID_SENSOR_INDEXL ] * PID_SENSOR_SCALEL;

            // calculate error
            pidErrorL = pidSensorCurrentValueL - pidRequestedValueL;

            // integral - if Ki is not 0
            if( pidL_Ki != 0 )
                {
                // If we are inside controlable window then integrate the error
                if( abs(pidErrorL) < PID_INTEGRAL_LIMITL )
                    pidIntegralL = pidIntegralL + pidErrorL;
                else
                    pidIntegralL = 0;
                }
            else
                pidIntegralL =PID_DRIVE_MAXL;
            if( pidDriveL < PID_DRIVE_MINL )
                pidDriveL = PID_DRIVE_MINL;

            // send to motor
            motor[ PID_MOTOR_INDEXL ] = pidDriveL * PID_MOTOR_SCALEL;
            }
        else
            {
            // clear all
            pidErrorL      = 0;
            pidLastErrorL  = 0;

            // calculate the derivative
            pidDerivativeL = pidErrorL - pidLastErrorL;
            pidLastErrorL  = pidErrorL;

            // calculate drive
            pidDriveL = (pidL_Kp * pidErrorL) + (pidL_Ki * pidIntegralL) + (pidL_Kd * pidDerivativeL);

            // limit drive
            if( pidDriveL > PID_DRIVE_MAXL )
                pidDriveL =
            pidIntegralL   = 0;
            pidDerivativeL = 0;
            motor[ PID_MOTOR_INDEXL ] = 0;
            }

        // Run at 50Hz
        wait1Msec( 10 );
        }
}

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Example main task                                                                  */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

//task main{
//    // send the motor off somewhere
//    pidRequestedValue = 360;
//
//  // start the PID task
//    StartTask( PIDLeftControl );
//
//    // use joystick to modify the requested position
//    while( true )
//        {
//        // maximum change for pidRequestedValue will be 127/4*20, around 640 counts per second
//        // free spinning motor is 100rmp so 1.67 rotations per second
//        // 1.67 * 360 counts is 600
//
//        pidRequestedValue = pidRequestedValue + (vexRT[ Ch2 ]/4);
//
//        wait1Msec(10);
//        }
//}




// PID using optical shaft encoder
//
// Shaft encoder has 360 pulses per revolution
//

#define PID_SENSOR_INDEXR    EncoderDriveRight
#define PID_SENSOR_SCALER    1

#define PID_MOTOR_INDEXR     DriveRightOne
#define PID_MOTOR_SCALER     -1

#define PID_DRIVE_MAXR       127
#define PID_DRIVE_MINR     (-127)

#define PID_INTEGRAL_LIMITR  50

// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
float  pidR_Kp = 2.0;
float  pidR_Ki = 0.04;
float  pidR_Kd = 0.0;

static int   pidRunning = 1;
static float pidRequestedValue;

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task PIDRightControl()
{
		motor[DriveRightTwo] = motor[DriveRightOne];    //Keep Left Drive Motor Power The Same

    float  pidSensorCurrentValueR;

    float  pidErrorR;
    float  pidLastErrorR;
    float  pidIntegralR;
    float  pidDerivativeR;
    float  pidDriveR;

    // If we are using an encoder then clear it
    if( SensorType[ PID_SENSOR_INDEXR ] == sensorQuadEncoder )
        SensorValue[ PID_SENSOR_INDEXR ] = 0;

    // Init the variables - thanks Glenn :)
    pidLastErrorR  = 0;
    pidIntegralR   = 0;

    while( true )
        {
        // Is PID control active ?
        if( pidRunning )
            {
            // Read the sensor value and scale
            pidSensorCurrentValueR = SensorValue[ PID_SENSOR_INDEXR ] * PID_SENSOR_SCALER;

            // calculate error
            pidErrorR = pidSensorCurrentValueR - pidRequestedValue;

            // integral - if Ki is not 0
            if( pidR_Ki != 0 )
                {
                // If we are inside controlable window then integrate the error
                if( abs(pidErrorR) < PID_INTEGRAL_LIMITR )
                    pidIntegralR = pidIntegralR + pidErrorR;
                else
                    pidIntegralR = 0;
                }
            else
                pidIntegralR =PID_DRIVE_MAXR;
            if( pidDriveR < PID_DRIVE_MINR )
                pidDriveR = PID_DRIVE_MINR;

            // send to motor
            motor[ PID_MOTOR_INDEXR ] = pidDriveR * PID_MOTOR_SCALER;
            }
        else
            {
            // clear all
            pidErrorR      = 0;
            pidLastErrorR  = 0;

            // calculate the derivative
            pidDerivativeR = pidErrorR - pidLastErrorR;
            pidLastErrorR  = pidErrorR;

            // calculate drive
            pidDriveR = (pidR_Kp * pidErrorR) + (pidR_Ki * pidIntegralR) + (pidR_Kd * pidDerivativeR);

            // limit drive
            if( pidDriveR > PID_DRIVE_MAXR )
                pidDriveR =
            pidIntegralR   = 0;
            pidDerivativeR = 0;
            motor[ PID_MOTOR_INDEXR ] = 0;
            }

        // Run at 50Hz
        wait1Msec( 10 );
        }
}

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Example main task                                                                  */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

//task main{
//    // send the motor off somewhere
//    pidRequestedValue = 360;
//
//  // start the PID task
//    StartTask( PIDLeftControl );
//
//    // use joystick to modify the requested position
//    while( true )
//        {
//        // maximum change for pidRequestedValue will be 127/4*20, around 640 counts per second
//        // free spinning motor is 100rmp so 1.67 rotations per second
//        // 1.67 * 360 counts is 600
//
//        pidRequestedValue = pidRequestedValue + (vexRT[ Ch2 ]/4);
//
//        wait1Msec(10);
//        }
//}

////////////////////////////////////End PID Control//////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol()
{
	    char  str[32];

    bLCDBacklight = true;

    // Start the flywheel control task
//////////    StartTask( FwControlTask );

    // Main user control loop
	while (true)
	{

  motor[DriveRightTwo] = motor[DriveRightOne];	//Keep Right Drive Motor Power The Same

  StartTask(UserDrive);													//True Speed Control

	      																				// FlyWheel Velocity Control

  			// Different speeds set by buttons
        if( vexRT[ Btn8L ] == 1 )
            FwVelocitySet( &flywheel, 360, 0.77 );
        if( vexRT[ Btn8U ] == 1 )
            FwVelocitySet( &flywheel, 200, 0.66 );
        if( vexRT[ Btn8R ] == 1 )
            FwVelocitySet( &flywheel, 100, 0.3 );
        if( vexRT[ Btn8D ] == 1 )
            FwVelocitySet( &flywheel, 00, 0 );

        // Display useful things on the LCD
        sprintf( str, "%4d %4d  %5.2f", flywheel.target,  flywheel.current, nImmediateBatteryLevel/1000.0 );
        displayLCDString(0, 0, str );
        sprintf( str, "%4.2f %4.2f ", flywheel.drive, flywheel.drive_at_zero );
        displayLCDString(1, 0, str );

        // Don't hog the cpu :)
        wait1Msec(10);

      if(vexRT[Btn8U] == 1)
      	StartTask(FlyWheelSafe);
     else if(vexRT[Btn8D] ==1)
       StopTask(FlyWheelSafe);
	}
}
